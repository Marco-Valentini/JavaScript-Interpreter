# Grammar is composed of definitions (named literals and named terminals) and some directives (at the end)
?start: statement+ // a program is composed of one or more statement

?statement: print_statement
            | input_statement
            | variable_declaration
            | expression ";"?
            | if_statement
            | while_statement
            | return_statement
            | function_declaration
            | function_call ";"?
            | block

?block: "{" statement* "}"

?print_statement: "console" "." "log" "(" expression ")" ";"?

?input_statement: "prompt" "(" expression ")" ";"?

?variable_declaration :("let"|"var"|"const") IDENTIFIER ("=" expression)?
                      |("let"|"var"|"const")? IDENTIFIER ("=" expression)

?function_declaration : "function" IDENTIFIER "(" parameter_list? ")" block

?parameter_list: IDENTIFIER ("," IDENTIFIER)*

?function_call: IDENTIFIER "(" argument_list? ")"

?argument_list: (IDENTIFIER "=")? expression ("," (IDENTIFIER "=")? expression)*

?return_statement: "return" expression? ";"?

?if_statement : "if" "(" expression ")" statement ("else" statement)?  # this way we include all the possible cases, statement cn be a block or another if statement
# TODO forse sarebbe più opportuno specificare una boolean condition piuttosto che generica expression
?while_statement  : "while" "(" expression ")" statement

?expression: "(" expression ")"
            | template_literal
            | "true" -> true
            | "false" -> false
            | "null" -> null
            | "undefined" -> undefined
            | logical_or
            | logical_and
            | equality  # equality with == in JS
            | strict_equality  # equality with === in JS
            | relational
            | additive
            | term
            | unary
            | array

term : multiplicative
     | factor
     | "(" additive ")"
     | "(" term ")"

factor : STRING
       | NUMBER
       | IDENTIFIER
       | IDENTIFIER "[" expression "]" -> vector_access

?array  : "[" [expression ("," expression)*] "]"  # TODO come valutare espressioni in place

?logical_or: expression "||" expression

?logical_and: expression "&&" expression

?equality: expression "==" expression  # TODO verifica se serve rinominare per far funzionare
            | expression "!=" expression -> inequality

?strict_equality: expression "===" expression
                    | expression "!==" expression -> strict_inequality

?relational: expression "<" expression -> less_than
            | expression ">" expression -> greater_than
            | expression "<=" expression -> less_than_or_equal
            | expression ">=" expression -> greater_than_or_equal

additive: expression "+" expression -> add  # TODO capisci come gestire precedenze e associatività (anche da slides)
           | expression "-" expression -> sub

multiplicative: term "*" term -> mul
               | term "/" term -> div

?unary: "-" expression -> neg  #TODO controlla come gestire - e a cosa applicarlo
        | "!" expression -> not_

?template_literal: "`" (template_string_part | "${" expression "}")* "`"

?template_string_part: /[^$`]+/

STRING: "'" _STRING_INNER* "'"
        | "\"" _STRING_INNER* "\""


// comment management (ignore them)
COMMENT: "//" /[^\n]/* | "/*" /./* "*/"

%import common.ESCAPED_STRING
%import common._STRING_INNER
%import common.CNAME -> IDENTIFIER
%import common.NUMBER  # TODO vedi se serve mettere unsigned
%import common.WS

%ignore COMMENT
%ignore WS

