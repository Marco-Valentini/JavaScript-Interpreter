# Grammar is composed of definitions (named literals and named terminals) and some directives (at the end)
?start: statement+ // a program is composed of one or more statement

?statement: print_statement ";"?
            | input_statement ";"?
            | variable_statement ";"?
            | expression ";"?
            | if_statement
            | while_statement
            | return_statement ";"?
            | function_declaration
            | function_call ";"?
            | block
# TODO valutare se nel loop aggiungere continue e break statement come produzione di statement

?block: "{" statement* "}"

?print_statement: "console" "." "log" "(" expression ")" ";"?

input_statement: "prompt" "(" expression ")" ";"? # prompt can take whatever input you give to it

# the ! is required to not filter keywords like let/const/var
!variable_statement: ("let"|"var"|"const") IDENTIFIER ("=" expression)?
                    |("let"|"var"|"const")? IDENTIFIER ("=" expression)  # we can define but not assign a variable or vice versa
                    |("let"|"var"|"const") IDENTIFIER ("=" input_statement)?
                    |("let"|"var"|"const")? IDENTIFIER ("=" input_statement)

!variable_assignment: IDENTIFIER "+=" expression
                    | IDENTIFIER "-=" expression
                    | IDENTIFIER "*=" expression
                    | IDENTIFIER "/=" expression
                    | IDENTIFIER "++"
                    | IDENTIFIER "--"
                    | "++" IDENTIFIER
                    | "--" IDENTIFIER

!function_declaration : "function" IDENTIFIER "(" parameter_list? ")" block

?parameter_list: IDENTIFIER ("," IDENTIFIER)*

!function_call: IDENTIFIER "(" argument_list? ")"

?argument_list: (IDENTIFIER "=")? expression ("," (IDENTIFIER "=")? expression)*

!return_statement: "return" expression? ";"?

# branching production
?if_statement : "if" "(" expression ")" statement ("else" statement)?  # this way we include all the possible cases, statement cn be a block or another if statement

# iteration production
?while_statement  : "while" "(" expression ")" statement

?expression: "(" expression ")"
            | template_literal
            | "null" -> null
            | "undefined" -> undefined
            | logical_or
            | logical_and
            | equality  # equality with == in JS
            | strict_equality  # equality with === in JS
            | relational
            | additive
            | term
            | logical_not
            | negative
            | array
            | variable_assignment

term : multiplicative
     | factor
     | "(" additive ")"
     | "(" term ")"

factor : STRING
       | NUMBER
       | BOOL
       | IDENTIFIER
       | IDENTIFIER "[" expression "]" -> vector_access

?array  : "[" [expression ("," expression)*] "]"  # TODO come valutare espressioni in place

?logical_or: expression "||" expression
           | "(" logical_or ")"

?logical_and: expression "&&" expression
            | "(" logical_and ")"

?equality: expression "==" expression  # TODO verifica se serve rinominare per far funzionare
            | expression "!=" expression -> inequality

?strict_equality: expression "===" expression
                    | expression "!==" expression -> strict_inequality

?relational: expression "<" expression -> less_than
            | expression ">" expression -> greater_than
            | expression "<=" expression -> less_than_or_equal
            | expression ">=" expression -> greater_than_or_equal
            | "(" relational ")"

additive: expression "+" expression -> add  # TODO capisci come gestire precedenze e associativitÃ  (anche da slides)
           | expression "-" expression -> sub

multiplicative: term "*" term -> mul
               | term "/" term -> div

logical_not: "!" expression
            | "!" "(" logical_not ")"

negative: "-" expression
         | "-" "(" negative ")"

?template_literal: "`" (template_string_part | "${" expression "}")* "`"

?template_string_part: /[^$`]+/

BOOL .1: "true" | "false"

STRING: "'" _STRING_INNER* "'"
        | "\"" _STRING_INNER* "\""


// comment management (ignore them)
COMMENT: "//" /[^\n]/* | "/*" /./* "*/"

%import common.ESCAPED_STRING
%import common._STRING_INNER
%import common.CNAME -> IDENTIFIER
%import common.NUMBER  # TODO vedi se serve mettere unsigned
%import common.WS

%ignore COMMENT
%ignore WS

